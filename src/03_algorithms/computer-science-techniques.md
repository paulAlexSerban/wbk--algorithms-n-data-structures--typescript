# Computer Science Techniques
List of computer science techniques, sorted by difficulty (from beginner to advanced) and priority (based on how fundamental and frequently used they are):

### Beginner Level

1. **Greedy Algorithms**
   - Priority: High
   - Description: Make the locally optimal choice at each stage.

2. **Two-pointer Technique**
   - Priority: High
   - Description: Use two pointers to traverse the array and solve problems related to subarrays or pairs.

3. **Sorting Algorithms (e.g., QuickSort, MergeSort, Bubble Sort)**
   - Priority: High
   - Description: Arrange the elements of a list in a certain order.

4. **Hashing**
   - Priority: High
   - Description: Use hash tables to achieve constant-time complexity for search, insert, and delete operations.

5. **Sliding Window Technique**
   - Priority: Medium
   - Description: Use a window to scan over a portion of data to find subarrays or substrings that satisfy a condition.

6. **Binary Search**
   - Priority: High
   - Description: Efficiently find the position of a target value within a sorted array.

7. **Basic Data Structures (e.g., Arrays, Linked Lists, Stacks, Queues)**
   - Priority: High
   - Description: Fundamental structures to store and organize data.

### Intermediate Level

8. **Depth-First Search (DFS) and Breadth-First Search (BFS)**
   - Priority: High
   - Description: Traverse or search tree or graph data structures.

9. **Dynamic Programming**
   - Priority: High
   - Description: Solve problems by breaking them down into simpler subproblems and storing the results.

10. **Divide and Conquer**
    - Priority: High
    - Description: Divide the problem into smaller subproblems, solve them independently, and combine their solutions.

11. **Backtracking**
    - Priority: Medium
    - Description: Build a solution incrementally and backtrack when a condition fails.

12. **Union-Find / Disjoint Set Union (DSU)**
    - Priority: Medium
    - Description: Keep track of a partition of a set into disjoint subsets.

13. **Heaps and Priority Queues**
    - Priority: Medium
    - Description: Retrieve the largest or smallest element efficiently.

14. **Trie (Prefix Tree)**
    - Priority: Medium
    - Description: Efficiently store and search a dynamic set of strings.

### Advanced Level

15. **Graph Algorithms (e.g., Dijkstra's, Floyd-Warshall, A*)**
    - Priority: High
    - Description: Find the shortest path, minimum spanning tree, and other properties of graphs.

16. **Segment Trees and Binary Indexed Trees (Fenwick Trees)**
    - Priority: Medium
    - Description: Efficiently answer range queries and update array elements.

17. **String Matching Algorithms (e.g., KMP, Rabin-Karp)**
    - Priority: Medium
    - Description: Find occurrences of a substring within a string efficiently.

18. **Network Flow Algorithms (e.g., Ford-Fulkerson, Edmonds-Karp)**
    - Priority: Medium
    - Description: Solve problems related to the flow of resources in a network.

19. **Advanced Data Structures (e.g., AVL Trees, Red-Black Trees, Splay Trees)**
    - Priority: Medium
    - Description: Self-balancing binary search trees for efficient search, insertion, and deletion.

20. **Suffix Arrays and Suffix Trees**
    - Priority: Medium
    - Description: Efficiently handle various string processing tasks.

21. **Linear Programming**
    - Priority: Low
    - Description: Optimize a linear objective function subject to linear equality and inequality constraints.

### Expert Level

22. **Monte Carlo and Las Vegas Algorithms**
    - Priority: Low
    - Description: Use randomness to solve problems, with varying degrees of probability and certainty.

23. **Approximation Algorithms**
    - Priority: Low
    - Description: Find near-optimal solutions to complex optimization problems.

24. **Bit Manipulation**
    - Priority: Low
    - Description: Perform operations directly on bits for optimization and low-level programming.

25. **Game Theory and Minimax Algorithms**
    - Priority: Low
    - Description: Make optimal decisions in competitive environments.

26. **Randomized Algorithms**
    - Priority: Low
    - Description: Use random numbers to influence the behavior of algorithms.

27. **Computational Geometry**
    - Priority: Low
    - Description: Solve problems related to the geometry of objects in space.

28. **Number Theory Algorithms**
    - Priority: Low
    - Description: Solve problems based on properties of numbers, useful in cryptography and coding theory.

29. **Quantum Algorithms**
    - Priority: Low
    - Description: Use principles of quantum mechanics to perform computations.

This list should give you a good overview of the techniques to prioritize learning in computer science, starting from the most fundamental and widely applicable to the more advanced and specialized ones.